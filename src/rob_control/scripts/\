#!/usr/bin/env python
# __*__coding:utf-8__*__

import sys
import copy
import rospy
import actionlib
import threading
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import RobotState
import geometry_msgs.msg
from control_msgs.msg import FollowJointTrajectoryAction
from trajectory_msgs.msg import JointTrajectory
from sensor_msgs.msg import JointState
from std_msgs.msg import Header
from diagnostic_msgs.msg import *
from math import pi as PI, degrees, radians
from joints import Joint
import minimalmodbus as modbus

G_JOINT_MSG = JointState()
SER_ARM = modbus.Instrument(port='/dev/ttyS6', slaveaddress=2)

G_JOINTS = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']
G_POSITION = [radians(i) for i in [-11.686,64.865,-15.943,55.433,47.906,-21.150]]

G_SER_IN_USE = 0 # 判断串口是否被进程占用
HOME_FLAG = False # 机器人在原点标志

DEGREE_OFFSET = 400 # 机器人寄存器不能写入负数，故角度偏移400
DEGREE_RATIO = 10        # 角度放大比例
DEBUG = True

#寄存器地址
ARM_READY_REG = 100
POINT1_OK_REG = 101
POINT2_OK_REG = 102
POINT_OK_REG = 106
POINT_CUR_REG = 107
POINT1_START_REG = 113
POINT2_START_REG = 119



def arm_init():
    global G_SER_IN_USE
    global G_JOINT_MSG
    global SER_ARM
    
    rospy.init_node('arm_controller')
    G_JOINT_MSG.header = Header()
    G_JOINT_MSG.header.stamp = rospy.Time.now()
    G_JOINT_MSG.name = G_JOINTS
    G_JOINT_MSG.position = G_POSITION
    G_JOINT_MSG.velocity = []
    G_JOINT_MSG.effort = []
    SER_ARM.serial.baudrate = 115200
    SER_ARM.serial.timeout = 0.1
    SER_ARM.serial.write_timeout = 0.1
    
    rate = rospy.Rate(50.0)
    pup = rospy.Publisher('joint_states', JointState, queue_size = 5)
    # sub = rospy.Subscriber('joint_states', JointState, callback)
    ''' 
    while not read_reg(ARM_READY_REG):
        ## 等待机器人启动
        print 'waiting for arm'
        rospy.sleep(0.5)
    current_joints = read_joints(POINT1_START_REG, 6)
    while current_joints == None:
        current_joints = read_joints(POINT1_START_REG, 6)
        print 'waiting for read current position'
        rospy.sleep(0.5)
    G_JOINT_MSG.position = current_joints
    '''
    #定义并启动发布者多线程
    pup_thread = threading.Thread(target=pup_thread_loop,args = (pup,), name='PubLoopThread')
    # 控制器线程
    act_server_thread = threading.Thread(target=act_server_thread_loop, name='ActLoopThread') 
    # 设置目标位置线程
    set_goal_thread = threading.Thread(target=set_goal_loop, name='SetGoalThread') 
    
    pup_thread.start()
    act_server_thread.start()
    set_goal_thread.start()
    print 'start thread'
    pup_thread.join()
    act_server_thread.join()
    set_goal_thread.joint()
    # rospy.spin()

# 发布者线程主循环
def pup_thread_loop(pup):
    # pup = rospy.Publisher('joint_states', JointState, queue_size = 5)
    while not rospy.is_shutdown():
        if not G_SER_IN_USE:
            G_JOINT_MSG.header.stamp = rospy.Time.now()
        pup.publish(G_JOINT_MSG)
        # print G_JOINT_MSG
        rospy.sleep(0.1)
def act_server_thread_loop():
    FollowController()
    rospy.spin()



def cal_pose(x,y,z,ax,ay,az,aw, reference_frame = 'base_link'):
   # 根据参数返回 geometry_msgs.msg.Pose()
    target_pose = geometry_msgs.msg.Pose()
    target_pose.position.x = x
    target_pose.position.y = y
    target_pose.position.z = z
    target_pose.orientation.x = ax
    target_pose.orientation.y = ay
    target_pose.orientation.z = az
    target_pose.orientation.w = aw
    return target_pose

def cal_min_traj(group, end_joints, start_pose=None, end_pose=None):
    group.set_start_state(robot_state)
    group.set_joint_value_target(end_joints)
    try:
        traj = arm.plan()
    except:
        return False
    for i in range(10):
        try:
            traj0 = arm.plan()
            if len(traj0.joint_trajectory.points)<len(traj.joint_trajectory.points):
                traj = traj0
        except:
            pass
    return traj

## 多路径点规划
def cal_multi_point_traj(group, way_points):
    len_way = len(way_points)
    traj_list = []
    if len_way > 1:
        for i in range(len_way-1):
            traj = cal_min_traj(group, way_points[i],way_points[i+1])
            if traj0:
                traj_list += traj.joint_trajectory.points
            else:
                return False
        traj.joint_trajectory.points = traj_list
        return traj
    else:
        return False


def set_goal_loop():

    # 初始化move_group的API
    moveit_commander.roscpp_initialize(sys.argv)
    # 初始化move group控制机械臂中的 arm
    arm = moveit_commander.MoveGroupCommander('arm')
    # 获取终端link名称
    end_effector_link = arm.get_end_effector_link()
    # 设置目标位置所使用的参考坐标系
    reference_frame = 'base_link'
    arm.set_pose_reference_frame(reference_frame)
    # 当运动规划失败后，允许重新规划
    arm.allow_replanning(True)
    arm.set_num_planning_attempts(5)
    # 设置位姿的允许误差
    arm.set_goal_position_tolerance(0.003)
    arm.set_goal_orientation_tolerance(0.005) 
    # 设置机械臂当前的状态为运动初始状态
    arm.set_start_state_to_current_state()
    # 求home_work_joints 到 home_joints最短路径
    # traj = cal_multi_point_traj(arm, way_work_home)

    # 各固定点初始化
    home_joints =[radians(i) for i in [89.156,57.127,38.238,-6.354,96.253,0]]
    release_joints =[radians(i) for i in [89.154,50.331,13.980,-6.95,65.4,0]]
    medium_joints = [radians(i) for i in [-19.654,88.135,-5.039,4.160,78.831,0]]
    home_work_joints = [radians(i) for i in [-90,75.795,-24.434,5.566,-33.123,0]]
    # 关节值对应的POSE
    home_pose = cal_pose(0.0333, 1.048, 0.48138, 0.99835, -0.01376, 0.05507, 0.00819)
    release_pose = cal_pose(0.0333, 1.048, 0.07351, 0.99829, 0.01759, 0.05479, 0.00994)
    medium_pose = cal_pose(0.67435, -0.22916, 0.44435, -0.56995, 0.82005, -0.00978, 0.05071)
    home_work_pose = cal_pose(0.039, -0.99398, 0.18418, 0.03735, 0.76177, -0.64627, 0.02561)
    
    way_joints=[home_work_joints,  home_joints, release_joints]
    way_pose=[home_work_pose, medium_pose, home_pose, release_pose, home_pose, medium_pose]
    # home点到work点路径点
    way_point_home_to_work = [home_pose, medium_pose, home_work_pose]
    # work点到home点路径点
    way_point_work_to_home = copy.deepcopy(way_point_home_to_work)
    way_point_work_to_home.reverse()


    ## 设置目标位置进程主循环
    while not read_reg(ARM_READY_REG):
        ## 等待机器人启动
        print 'waiting for arm:' + str(read_reg(ARM_READY_REG))
        rospy.sleep(2)
    if  not DEBUG:
        current_joints = read_joints(POINT_CUR_REG, 6)
        while current_joints == None:
            current_joints = read_joints(POINT1_START_REG, 6)
            print 'waiting for read current position'
            rospy.sleep(2)
        G_JOINT_MSG.position = current_joints
        # print ([degrees(i) for i in current_joints])

    # 关键点定义
    print 'Waiting for RVIZ======================'
    rospy.sleep(10)
    print 'start set_goal'
    
    '''
    while not traj:
        traj = cal_multi_point_traj(arm, way_work_home)
        print 'Repanning way from work to home'
        rospy.sleep(2)
    '''
    # 清空位姿信息
    # arm.clear_pose_targets()
    
    # 设置机械臂终端运动的目标位姿
    # target_pose = home_work_pose
    # arm.set_pose_target(target_pose, end_effector_link)
    # arm.set_pose_targets(way_pose)
    '''
    arm.set_joint_value_target(home_work_joints)
    traj = arm.plan()
    print(traj)
    traj = traj.joint_trajectory
    execute_trajectory(traj)
    print 'current home work position is:'
    rospy.sleep(100)
    '''
    '''
    # 设置机械臂终端目标关节值
    while True:
        for i in way_joints:
            arm.set_joint_value_target(i)
            traj = arm.plan()
            traj = traj.joint_trajectory
            if execute_trajectory(traj):
                print 'executed'
        if execute_trajectory(traj):
            print 'executed'
        rospy.sleep(5)
    '''
    
    # 笛卡尔路径规划
    # waypoints=[home_work_pose, medium_pose, home_pose, release_pose, home_pose, medium_pose, home_work_pose]
    fraction = 0.0 # 路径规划覆盖率
    maxtries = 100 # 最大尝试规划次数
    attempts = 0 # 已经尝试规划次数
    # 尝试规划一条笛卡尔空间下的路径，依次通过所有路径点
    while fraction < 1.0 and attempts < maxtries:
        (traj, fraction) = arm.compute_cartesian_path(way_pose, 0.02,0.0,True)
        traj = traj.joint_trajectory
        attempts += 1
        # 打印规划进程
        if attempts % 10 == 0:
            rospy.loginfo('still trying after' + str(attempts)) + 'attempts...'
        if fraction == 1.0:
            rospy.loginfo('Path computed successfully. Moving the arm.')
    # 执行运动路径
    # print traj
    print execute_trajectory(traj)

    rospy.sleep(1)

'''
## 寄存器操作函数群
'''
def write_joints(start_reg_addr,point, indexes):
    # 向串口下发目标关节值，并返回是否成功
    desired = [point.positions[i] for i in indexes]
    if DEBUG:
        current_joints = read_joints(POINT1_START_REG, 6)
        if current_joints:
            G_JOINT_MSG.header.stamp = rospy.Time.now()
            G_JOINT_MSG.position = current_joints
    for i in indexes:
        ## 循环发送各关节命令至机械手，运动到当前点
        # self.joints[i].set_current_psition(desired[i])
        # 把角度偏移DEGREE_OFFSET 并放大 DEGREE_RATIO倍，写入寄存器
        # 写入不成功,返回False
        if not write_reg(start_reg_addr,int((degrees(desired[i])+DEGREE_OFFSET)*DEGREE_RATIO)):
            return False
        # 寄存器地址+1，准备写入下一个关节值
        start_reg_addr += 1
    
    return True

def read_joints(start_reg_addr,joints_num):
    ## 读各关节值并返回
    joints = read_reg(start_reg_addr,joints_num)
    
    if joints == None:
        return None
    else:
        for i in range(len(joints)):
            joints[i] = radians(joints[i]/10.0-DEGREE_OFFSET)
        print([degrees(i) for i in joints])
        return joints

def write_reg(addr, value):
    ## 写寄存器，并返回是否成功
    try:
        SER_ARM.write_register(addr,value)
        return True
    except:
        return False

def read_reg(addr,count = None):
    ## 读寄存器，成功则返回读取的值，否则返回None
    try:
        if count == None:
            return SER_ARM.read_register(addr)
        else:
            return SER_ARM.read_registers(addr,count)
    except:
        return None

# 执行轨迹
def execute_trajectory(traj):
    rospy.loginfo('Executing trajectory')
    rospy.logdebug(traj)
    
    # 取出轨迹
    try:
        indexes = [traj.joint_names.index(joint)
                    for joint in G_JOINTS]
    except ValueError as val:
        rospy.logerr('Invalid joint in trajetory.')

    len_trajs = len(traj.points)
    odd_flag = len_trajs % 2
    G_SER_IN_USE = 1
    i = 0
    while i <len_trajs:
        timeout = 0
        read1_flag = read_reg(POINT1_OK_REG)
        read2_flag = read_reg(POINT1_OK_REG)
        # print str(read1_flag) + '========' + str(read2_flag)
        # 调试模式
        if DEBUG:
            read1_flag = not read1_flag
            read2_flag = not read2_flag
            current_position_reg = POINT1_START_REG
        else:
            current_position_reg = POINT_CUR_REG
        while read1_flag and read2_flag:
            ## 等待点1和点2中一个寄存器准备好接收关节值
            timeout +=0.01
            rospy.sleep(0.01)
            # 读机器人当前位姿POINT_CUR_REG
            current_joints = read_joints(current_position_reg, 6)
            if current_joints:
                G_JOINT_MSG.header.stamp = rospy.Time.now()
                G_JOINT_MSG.position = current_joints
            if timeout > 10 or read1_flag == None or read2_flag == None:
                return False
            read1_flag = read_reg(POINT1_OK_REG)
            read2_flag = read_reg(POINT2_OK_REG)
            if DEBUG:
                read1_flag = not read1_flag
                read2_flag = not read2_flag

        point = traj.points[i]
        # 轨迹点长度为奇数，且是最后一个
        if  not read1_flag:
            # print 'write point1=========='
            write_joints(POINT1_START_REG, point, indexes)
            write_reg(POINT1_OK_REG,1)
            i+=1
        elif (not read2_flag) and i < len_trajs:
            # print 'write point2========='
            point = traj.points[i]
            write_joints(POINT2_START_REG, point, indexes)
            write_reg(POINT2_OK_REG,1)
            i+=1
    G_SER_IN_USE = 0
    return True




class FollowController:
# 驱动核心代码
    def __init__(self,name='arm_controller'):
        
        self.name = name
        # action server 创建
        self.server = actionlib.SimpleActionServer(
                'r_rob_mover/follow_joint_trajectory', 
                FollowJointTrajectoryAction, 
                execute_cb = self.action_callback, auto_start = False)
        self.server.start()
        rospy.loginfo('Started FollowController')

    # 回调函数
    def action_callback(self, goal):
        print('********actionCb*********')
        rospy.loginfo(self.name + ' Action goal recieved.')
        traj = goal.trajectory
        rospy.loginfo(self.name + ':Done')

    

if __name__ == '__main__':
    try:
        rospy.loginfo('start follow controller...')
        arm_init()
    except rospy.ROSInterruptException:
        rospy.loginfo('Failed to start follow controller...')
    
